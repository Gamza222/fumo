{"file":"/Users/gamzaramazanov/Desktop/fumo/src/shared/lib/utils/cva/cva.ts","mappings":";AAAA;;;;;GAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCH;;;;GAIG;AACI,IAAM,GAAG,GAAG,UAAqB,MAAoB;IAC1D,OAAO,UAAC,KAAyC;QACvC,IAAA,IAAI,GAAkD,MAAM,KAAxD,EAAE,QAAQ,GAAwC,MAAM,SAA9C,EAAE,eAAe,GAAuB,MAAM,gBAA7B,EAAE,gBAAgB,GAAK,MAAM,iBAAX,CAAY;QACrE,IAAM,aAAa,yBAAQ,eAAe,GAAK,KAAK,CAAE,CAAC;QAEvD,yDAAyD;QACzD,IAAM,cAAc,GAAG,QAAQ;YAC7B,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,UAAC,UAAU;;gBACnC,IAAM,YAAY,GAAG,aAAa,CAAC,UAAwC,CAAC,CAAC;gBAC7E,IAAI,YAAY,KAAK,IAAI,IAAI,YAAY,KAAK,SAAS;oBAAE,OAAO,SAAS,CAAC;gBAC1E,OAAO,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAG,UAAU,CAAC,0CAAG,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;YACxD,CAAC,CAAC;YACJ,CAAC,CAAC,EAAE,CAAC;QAEP,2DAA2D;QAC3D,IAAM,sBAAsB,GAAG,gBAAgB;YAC7C,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,UAAC,eAAe;gBAC3B,IAAA,SAAS,GAAoB,eAAe,UAAnC,EAAK,UAAU,UAAK,eAAe,EAA9C,aAA4B,CAAF,CAAqB;gBACrD,IAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,UAAC,EAAY;wBAAX,GAAG,QAAA,EAAE,KAAK,QAAA;oBAC3D,IAAM,SAAS,GAAG,aAAa,CAAC,GAAiC,CAAC,CAAC;oBACnE,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;wBACzB,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;wBACnC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,CAAC;gBAC1C,CAAC,CAAC,CAAC;gBACH,OAAO,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC;YACzC,CAAC,CAAC;YACJ,CAAC,CAAC,EAAE,CAAC;QAEP,OAAO,8CAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,SAAK,cAAc,SAAK,sBAAsB,QAC3F,MAAM,CAAC,OAAO,CAAC;aACf,OAAO,CAAC,UAAC,IAAI;YACZ,IAAI,CAAC,IAAI;gBAAE,OAAO,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACtD,CAAC,CAAa,CAAC;IACnB,CAAC,CAAC;AACJ,CAAC,CAAC;AAnCW,QAAA,GAAG,OAmCd","names":[],"sources":["/Users/gamzaramazanov/Desktop/fumo/src/shared/lib/utils/cva/cva.ts"],"sourcesContent":["/**\n * @file This file contains a Class Variance Authority (CVA) utility.\n * CVA is a design pattern used to create a consistent and type-safe system for\n * building UI components with multiple style variants. This implementation is a\n * higher-order function that acts as a factory for variant-to-class-name logic.\n */\n\ntype VariantValue = string | boolean | null | undefined;\n\n/**\n * @example { primary: 'button-primary', secondary: 'button-secondary' }\n */\ntype VariantConfig = Record<string, string>;\ntype Variants = Record<string, VariantConfig>;\n\n/**\n * Defines the shape of the main configuration object for the `cva` function.\n * The generic `<V extends Variants>` creates a type-safe link between `variants`,\n * `defaultVariants`, and `compoundVariants`, ensuring they all use the same keys.\n */\ntype CvaConfig<V extends Variants> = {\n  /** The foundational CSS classes applied to every instance. */\n  base?: string | string[];\n\n  /** The core dictionary of all possible style variations. */\n  variants?: V;\n\n  /** Fallback values to use if a variant prop is not provided. */\n  defaultVariants?: { [K in keyof V]?: keyof V[K] };\n\n  /** Rules for applying styles based on a *combination* of other variants. */\n  compoundVariants?: Array<\n    {\n      [K in keyof V]?: keyof V[K] | Array<keyof V[K]>;\n    } & { className: string }\n  >;\n};\n\n/**\n * A factory function that creates a variant-resolver function based on a given config.\n * @param config The configuration object that defines all styling rules.\n * @returns A new function that takes component props and returns an array of class names.\n */\nexport const cva = <V extends Variants>(config: CvaConfig<V>) => {\n  return (props?: { [K in keyof V]?: VariantValue }): string[] => {\n    const { base, variants, defaultVariants, compoundVariants } = config;\n    const resolvedProps = { ...defaultVariants, ...props };\n\n    // Resolve standard variants based on the provided props.\n    const variantClasses = variants\n      ? Object.keys(variants).map((variantKey) => {\n          const variantValue = resolvedProps[variantKey as keyof typeof resolvedProps];\n          if (variantValue === null || variantValue === undefined) return undefined;\n          return variants?.[variantKey]?.[String(variantValue)];\n        })\n      : [];\n\n    // Resolve compound variants for handling style exceptions.\n    const compoundVariantClasses = compoundVariants\n      ? compoundVariants.map((compoundVariant) => {\n          const { className, ...conditions } = compoundVariant;\n          const isMatch = Object.entries(conditions).every(([key, value]) => {\n            const propValue = resolvedProps[key as keyof typeof resolvedProps];\n            return Array.isArray(value)\n              ? value.includes(String(propValue))\n              : String(propValue) === String(value);\n          });\n          return isMatch ? className : undefined;\n        })\n      : [];\n\n    return [...(Array.isArray(base) ? base : [base]), ...variantClasses, ...compoundVariantClasses]\n      .filter(Boolean)\n      .flatMap((item) => {\n        if (!item) return [];\n        return Array.isArray(item) ? item : item.split(' ');\n      }) as string[];\n  };\n};\n"],"version":3}