4da1c7fe262c65fb97427fc382c03bba
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var performance_monitor_1 = require("./performance-monitor");
var performance_enums_1 = require("../../types/performance.enums");
// Import performance mocks from factory
var browser_1 = require("@/shared/testing/mocks/browser");
// Setup performance mock
(0, browser_1.setupPerformanceMock)();
describe('PerformanceMonitor', function () {
    var monitor;
    beforeEach(function () {
        monitor = new performance_monitor_1.PerformanceMonitor();
        jest.clearAllMocks();
    });
    describe('addMetric', function () {
        it('should add a metric', function () {
            var metric = {
                name: 'test',
                value: 100,
                timestamp: Date.now(),
                rating: performance_enums_1.PerformanceRating.GOOD,
            };
            monitor.addMetric(metric);
            var metrics = monitor.getMetrics();
            expect(metrics).toHaveLength(1);
            expect(metrics[0]).toEqual(metric);
        });
    });
    describe('getMetricsByName', function () {
        it('should return metrics by name', function () {
            var metric1 = { name: 'test1', value: 100, timestamp: Date.now() };
            var metric2 = { name: 'test2', value: 200, timestamp: Date.now() };
            var metric3 = { name: 'test1', value: 300, timestamp: Date.now() };
            monitor.addMetric(metric1);
            monitor.addMetric(metric2);
            monitor.addMetric(metric3);
            var test1Metrics = monitor.getMetricsByName('test1');
            expect(test1Metrics).toHaveLength(2);
            expect(test1Metrics[0]).toEqual(metric1);
            expect(test1Metrics[1]).toEqual(metric3);
        });
    });
    describe('subscribe', function () {
        it('should notify subscribers when metrics are added', function () {
            var callback = jest.fn();
            var unsubscribe = monitor.subscribe(callback);
            monitor.addMetric({ name: 'test', value: 100, timestamp: Date.now() });
            expect(callback).toHaveBeenCalledWith(expect.objectContaining({
                metrics: expect.arrayContaining([expect.objectContaining({ name: 'test', value: 100 })]),
            }));
            unsubscribe();
        });
    });
    describe('clear', function () {
        it('should clear all metrics', function () {
            monitor.addMetric({ name: 'test', value: 100, timestamp: Date.now() });
            expect(monitor.getMetrics()).toHaveLength(1);
            monitor.clear();
            expect(monitor.getMetrics()).toHaveLength(0);
        });
    });
});
describe('measurePerformance', function () {
    it('should measure function execution time', function () {
        var fn = jest.fn(function () { return 'result'; });
        var result = (0, performance_monitor_1.measurePerformance)('test', fn);
        expect(result).toBe('result');
        expect(fn).toHaveBeenCalled();
        expect(performance_monitor_1.performanceMonitor.getMetrics()).toHaveLength(1);
    });
});
describe('measureAsyncPerformance', function () {
    it('should measure async function execution time', function () { return __awaiter(void 0, void 0, void 0, function () {
        var fn, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // Clear any existing metrics first
                    performance_monitor_1.performanceMonitor.clear();
                    fn = jest.fn(function () { return Promise.resolve('result'); });
                    return [4 /*yield*/, (0, performance_monitor_1.measureAsyncPerformance)('test', fn)];
                case 1:
                    result = _a.sent();
                    expect(result).toBe('result');
                    expect(fn).toHaveBeenCalled();
                    expect(performance_monitor_1.performanceMonitor.getMetrics()).toHaveLength(1);
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('getPerformanceTiming', function () {
    it('should return performance timing', function () {
        var timing = (0, performance_monitor_1.getPerformanceTiming)();
        expect(timing).toEqual({
            navigationStart: 0,
            loadEventEnd: 1000,
        });
    });
});
describe('getNavigationTiming', function () {
    it('should return navigation timing', function () {
        // Use mock navigation entries from factory
        var mockEntries = (0, browser_1.mockNavigationEntries)();
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var originalGetEntriesByType = window.performance.getEntriesByType;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        window.performance.getEntriesByType = jest.fn(function (type) {
            if (type === 'navigation') {
                return mockEntries;
            }
            return [];
        });
        var timing = (0, performance_monitor_1.getNavigationTiming)();
        expect(timing).toBeDefined();
        expect(timing === null || timing === void 0 ? void 0 : timing.name).toBe('navigation');
        expect(timing === null || timing === void 0 ? void 0 : timing.startTime).toBe(0);
        expect(timing === null || timing === void 0 ? void 0 : timing.duration).toBe(1000);
        // Restore original function
        window.performance.getEntriesByType = originalGetEntriesByType;
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dhbXphcmFtYXphbm92L0Rlc2t0b3AvZnVtby9zcmMvaW5mcmFzdHJ1Y3R1cmUvcGVyZm9ybWFuY2UvbGliL3BlcmZvcm1hbmNlLW1vbml0b3IvcGVyZm9ybWFuY2UtbW9uaXRvci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkRBTytCO0FBQy9CLG1FQUFrRTtBQUVsRSx3Q0FBd0M7QUFDeEMsMERBQTZGO0FBRTdGLHlCQUF5QjtBQUN6QixJQUFBLDhCQUFvQixHQUFFLENBQUM7QUFFdkIsUUFBUSxDQUFDLG9CQUFvQixFQUFFO0lBQzdCLElBQUksT0FBMkIsQ0FBQztJQUVoQyxVQUFVLENBQUM7UUFDVCxPQUFPLEdBQUcsSUFBSSx3Q0FBa0IsRUFBRSxDQUFDO1FBQ25DLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxXQUFXLEVBQUU7UUFDcEIsRUFBRSxDQUFDLHFCQUFxQixFQUFFO1lBQ3hCLElBQU0sTUFBTSxHQUFHO2dCQUNiLElBQUksRUFBRSxNQUFNO2dCQUNaLEtBQUssRUFBRSxHQUFHO2dCQUNWLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNyQixNQUFNLEVBQUUscUNBQWlCLENBQUMsSUFBSTthQUMvQixDQUFDO1lBRUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMxQixJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7WUFFckMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsa0JBQWtCLEVBQUU7UUFDM0IsRUFBRSxDQUFDLCtCQUErQixFQUFFO1lBQ2xDLElBQU0sT0FBTyxHQUFHLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQztZQUNyRSxJQUFNLE9BQU8sR0FBRyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7WUFDckUsSUFBTSxPQUFPLEdBQUcsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDO1lBRXJFLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDM0IsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMzQixPQUFPLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRTNCLElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN2RCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLFdBQVcsRUFBRTtRQUNwQixFQUFFLENBQUMsa0RBQWtELEVBQUU7WUFDckQsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzNCLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFaEQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUV2RSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsb0JBQW9CLENBQ25DLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDdEIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDekYsQ0FBQyxDQUNILENBQUM7WUFFRixXQUFXLEVBQUUsQ0FBQztRQUNoQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLE9BQU8sRUFBRTtRQUNoQixFQUFFLENBQUMsMEJBQTBCLEVBQUU7WUFDN0IsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUN2RSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTdDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNoQixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUVILFFBQVEsQ0FBQyxvQkFBb0IsRUFBRTtJQUM3QixFQUFFLENBQUMsd0NBQXdDLEVBQUU7UUFDM0MsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFNLE9BQUEsUUFBUSxFQUFSLENBQVEsQ0FBQyxDQUFDO1FBQ25DLElBQU0sTUFBTSxHQUFHLElBQUEsd0NBQWtCLEVBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRTlDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDOUIsTUFBTSxDQUFDLHdDQUFrQixDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFELENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMseUJBQXlCLEVBQUU7SUFDbEMsRUFBRSxDQUFDLDhDQUE4QyxFQUFFOzs7OztvQkFDakQsbUNBQW1DO29CQUNuQyx3Q0FBa0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFFckIsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBTSxPQUFBLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQXpCLENBQXlCLENBQUMsQ0FBQztvQkFDckMscUJBQU0sSUFBQSw2Q0FBdUIsRUFBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUE7O29CQUFsRCxNQUFNLEdBQUcsU0FBeUM7b0JBRXhELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBQzlCLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO29CQUM5QixNQUFNLENBQUMsd0NBQWtCLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7U0FDekQsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsc0JBQXNCLEVBQUU7SUFDL0IsRUFBRSxDQUFDLGtDQUFrQyxFQUFFO1FBQ3JDLElBQU0sTUFBTSxHQUFHLElBQUEsMENBQW9CLEdBQUUsQ0FBQztRQUN0QyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQ3JCLGVBQWUsRUFBRSxDQUFDO1lBQ2xCLFlBQVksRUFBRSxJQUFJO1NBQ25CLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMscUJBQXFCLEVBQUU7SUFDOUIsRUFBRSxDQUFDLGlDQUFpQyxFQUFFO1FBQ3BDLDJDQUEyQztRQUMzQyxJQUFNLFdBQVcsR0FBRyxJQUFBLCtCQUFxQixHQUFFLENBQUM7UUFFNUMsNkRBQTZEO1FBQzdELElBQU0sd0JBQXdCLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQztRQUNyRSw2REFBNkQ7UUFDN0QsTUFBTSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQUMsSUFBSTtZQUNqRCxJQUFJLElBQUksS0FBSyxZQUFZLEVBQUUsQ0FBQztnQkFDMUIsT0FBTyxXQUFXLENBQUM7WUFDckIsQ0FBQztZQUNELE9BQU8sRUFBRSxDQUFDO1FBQ1osQ0FBQyxDQUFRLENBQUM7UUFFVixJQUFNLE1BQU0sR0FBRyxJQUFBLHlDQUFtQixHQUFFLENBQUM7UUFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzdCLE1BQU0sQ0FBQyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sQ0FBQyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXBDLDRCQUE0QjtRQUM1QixNQUFNLENBQUMsV0FBVyxDQUFDLGdCQUFnQixHQUFHLHdCQUF3QixDQUFDO0lBQ2pFLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2dhbXphcmFtYXphbm92L0Rlc2t0b3AvZnVtby9zcmMvaW5mcmFzdHJ1Y3R1cmUvcGVyZm9ybWFuY2UvbGliL3BlcmZvcm1hbmNlLW1vbml0b3IvcGVyZm9ybWFuY2UtbW9uaXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGdldE5hdmlnYXRpb25UaW1pbmcsXG4gIGdldFBlcmZvcm1hbmNlVGltaW5nLFxuICBtZWFzdXJlQXN5bmNQZXJmb3JtYW5jZSxcbiAgbWVhc3VyZVBlcmZvcm1hbmNlLFxuICBwZXJmb3JtYW5jZU1vbml0b3IsXG4gIFBlcmZvcm1hbmNlTW9uaXRvcixcbn0gZnJvbSAnLi9wZXJmb3JtYW5jZS1tb25pdG9yJztcbmltcG9ydCB7IFBlcmZvcm1hbmNlUmF0aW5nIH0gZnJvbSAnLi4vLi4vdHlwZXMvcGVyZm9ybWFuY2UuZW51bXMnO1xuXG4vLyBJbXBvcnQgcGVyZm9ybWFuY2UgbW9ja3MgZnJvbSBmYWN0b3J5XG5pbXBvcnQgeyBtb2NrTmF2aWdhdGlvbkVudHJpZXMsIHNldHVwUGVyZm9ybWFuY2VNb2NrIH0gZnJvbSAnQC9zaGFyZWQvdGVzdGluZy9tb2Nrcy9icm93c2VyJztcblxuLy8gU2V0dXAgcGVyZm9ybWFuY2UgbW9ja1xuc2V0dXBQZXJmb3JtYW5jZU1vY2soKTtcblxuZGVzY3JpYmUoJ1BlcmZvcm1hbmNlTW9uaXRvcicsICgpID0+IHtcbiAgbGV0IG1vbml0b3I6IFBlcmZvcm1hbmNlTW9uaXRvcjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb25pdG9yID0gbmV3IFBlcmZvcm1hbmNlTW9uaXRvcigpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnYWRkTWV0cmljJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWRkIGEgbWV0cmljJywgKCkgPT4ge1xuICAgICAgY29uc3QgbWV0cmljID0ge1xuICAgICAgICBuYW1lOiAndGVzdCcsXG4gICAgICAgIHZhbHVlOiAxMDAsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgcmF0aW5nOiBQZXJmb3JtYW5jZVJhdGluZy5HT09ELFxuICAgICAgfTtcblxuICAgICAgbW9uaXRvci5hZGRNZXRyaWMobWV0cmljKTtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBtb25pdG9yLmdldE1ldHJpY3MoKTtcblxuICAgICAgZXhwZWN0KG1ldHJpY3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzWzBdKS50b0VxdWFsKG1ldHJpYyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRNZXRyaWNzQnlOYW1lJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIG1ldHJpY3MgYnkgbmFtZScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpYzEgPSB7IG5hbWU6ICd0ZXN0MScsIHZhbHVlOiAxMDAsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuICAgICAgY29uc3QgbWV0cmljMiA9IHsgbmFtZTogJ3Rlc3QyJywgdmFsdWU6IDIwMCwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG4gICAgICBjb25zdCBtZXRyaWMzID0geyBuYW1lOiAndGVzdDEnLCB2YWx1ZTogMzAwLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcblxuICAgICAgbW9uaXRvci5hZGRNZXRyaWMobWV0cmljMSk7XG4gICAgICBtb25pdG9yLmFkZE1ldHJpYyhtZXRyaWMyKTtcbiAgICAgIG1vbml0b3IuYWRkTWV0cmljKG1ldHJpYzMpO1xuXG4gICAgICBjb25zdCB0ZXN0MU1ldHJpY3MgPSBtb25pdG9yLmdldE1ldHJpY3NCeU5hbWUoJ3Rlc3QxJyk7XG4gICAgICBleHBlY3QodGVzdDFNZXRyaWNzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QodGVzdDFNZXRyaWNzWzBdKS50b0VxdWFsKG1ldHJpYzEpO1xuICAgICAgZXhwZWN0KHRlc3QxTWV0cmljc1sxXSkudG9FcXVhbChtZXRyaWMzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3N1YnNjcmliZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdGlmeSBzdWJzY3JpYmVycyB3aGVuIG1ldHJpY3MgYXJlIGFkZGVkJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IG1vbml0b3Iuc3Vic2NyaWJlKGNhbGxiYWNrKTtcblxuICAgICAgbW9uaXRvci5hZGRNZXRyaWMoeyBuYW1lOiAndGVzdCcsIHZhbHVlOiAxMDAsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTtcblxuICAgICAgZXhwZWN0KGNhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIG1ldHJpY3M6IGV4cGVjdC5hcnJheUNvbnRhaW5pbmcoW2V4cGVjdC5vYmplY3RDb250YWluaW5nKHsgbmFtZTogJ3Rlc3QnLCB2YWx1ZTogMTAwIH0pXSksXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2xlYXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhciBhbGwgbWV0cmljcycsICgpID0+IHtcbiAgICAgIG1vbml0b3IuYWRkTWV0cmljKHsgbmFtZTogJ3Rlc3QnLCB2YWx1ZTogMTAwLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gICAgICBleHBlY3QobW9uaXRvci5nZXRNZXRyaWNzKCkpLnRvSGF2ZUxlbmd0aCgxKTtcblxuICAgICAgbW9uaXRvci5jbGVhcigpO1xuICAgICAgZXhwZWN0KG1vbml0b3IuZ2V0TWV0cmljcygpKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdtZWFzdXJlUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgbWVhc3VyZSBmdW5jdGlvbiBleGVjdXRpb24gdGltZScsICgpID0+IHtcbiAgICBjb25zdCBmbiA9IGplc3QuZm4oKCkgPT4gJ3Jlc3VsdCcpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1lYXN1cmVQZXJmb3JtYW5jZSgndGVzdCcsIGZuKTtcblxuICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3Jlc3VsdCcpO1xuICAgIGV4cGVjdChmbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIGV4cGVjdChwZXJmb3JtYW5jZU1vbml0b3IuZ2V0TWV0cmljcygpKS50b0hhdmVMZW5ndGgoMSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdtZWFzdXJlQXN5bmNQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBtZWFzdXJlIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGlvbiB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBtZXRyaWNzIGZpcnN0XG4gICAgcGVyZm9ybWFuY2VNb25pdG9yLmNsZWFyKCk7XG5cbiAgICBjb25zdCBmbiA9IGplc3QuZm4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdyZXN1bHQnKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWVhc3VyZUFzeW5jUGVyZm9ybWFuY2UoJ3Rlc3QnLCBmbik7XG5cbiAgICBleHBlY3QocmVzdWx0KS50b0JlKCdyZXN1bHQnKTtcbiAgICBleHBlY3QoZm4pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICBleHBlY3QocGVyZm9ybWFuY2VNb25pdG9yLmdldE1ldHJpY3MoKSkudG9IYXZlTGVuZ3RoKDEpO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnZ2V0UGVyZm9ybWFuY2VUaW1pbmcnLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgcmV0dXJuIHBlcmZvcm1hbmNlIHRpbWluZycsICgpID0+IHtcbiAgICBjb25zdCB0aW1pbmcgPSBnZXRQZXJmb3JtYW5jZVRpbWluZygpO1xuICAgIGV4cGVjdCh0aW1pbmcpLnRvRXF1YWwoe1xuICAgICAgbmF2aWdhdGlvblN0YXJ0OiAwLFxuICAgICAgbG9hZEV2ZW50RW5kOiAxMDAwLFxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnZ2V0TmF2aWdhdGlvblRpbWluZycsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCByZXR1cm4gbmF2aWdhdGlvbiB0aW1pbmcnLCAoKSA9PiB7XG4gICAgLy8gVXNlIG1vY2sgbmF2aWdhdGlvbiBlbnRyaWVzIGZyb20gZmFjdG9yeVxuICAgIGNvbnN0IG1vY2tFbnRyaWVzID0gbW9ja05hdmlnYXRpb25FbnRyaWVzKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgY29uc3Qgb3JpZ2luYWxHZXRFbnRyaWVzQnlUeXBlID0gd2luZG93LnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlID0gamVzdC5mbigodHlwZSkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT09ICduYXZpZ2F0aW9uJykge1xuICAgICAgICByZXR1cm4gbW9ja0VudHJpZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSkgYXMgYW55O1xuXG4gICAgY29uc3QgdGltaW5nID0gZ2V0TmF2aWdhdGlvblRpbWluZygpO1xuICAgIGV4cGVjdCh0aW1pbmcpLnRvQmVEZWZpbmVkKCk7XG4gICAgZXhwZWN0KHRpbWluZz8ubmFtZSkudG9CZSgnbmF2aWdhdGlvbicpO1xuICAgIGV4cGVjdCh0aW1pbmc/LnN0YXJ0VGltZSkudG9CZSgwKTtcbiAgICBleHBlY3QodGltaW5nPy5kdXJhdGlvbikudG9CZSgxMDAwKTtcblxuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZnVuY3Rpb25cbiAgICB3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZSA9IG9yaWdpbmFsR2V0RW50cmllc0J5VHlwZTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==